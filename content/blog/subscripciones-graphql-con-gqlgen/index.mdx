---
title: Suscripciones GraphQL con gqlgen Parte 1 [backend]
date: "2020-12-25T23:28:00.000Z"
description: "¿No sabes cómo implementar suscripciones de GraphQL en Golang? Este post explica cómo agregar suscripciones 
a tu servidor con gqlgen"
tags: "graphql, real-time, golang, subscriptions, gqlgen, gqlgen subscriptions"
---

import Figure from "../../../src/components/figure"
import landing from "./landing.png"
import reviews from "./reviews.png"
import gif from './ghreviews.gif'

A la fecha, no hay tutoriales sobre cómo manejar suscripciones de graphql con
[gqlgen], por lo que quiero compartir, en un tutorial de dos partes, cómo
utilizar gqlgen en el backend y apollo en el frontend para desarrollar una
simple aplicación.

> En este post se asume que tienes un conocimiento básico de GraphQL y/o sabes
> cómo escribir escribir _"queries"_ y _"mutations"_.

- [Queries and mutations](https://graphql.org/learn/queries/)

# Parte 1: Backend

## ¿Qué son las suscripciones graphql?

_"Las [suscripciones] son una característica de [GraphQL] que permite a un
servidor enviar datos a sus clientes cuando ocurre un evento específico. Las
suscripciones se implementan normalmente con WebSockets. En esa configuración,
el servidor mantiene una conexión constante con su cliente suscrito. Esto
también rompe el "Ciclo de solicitud-respuesta"(Request-Response-Cycle) que se
utilizaba para todas las interacciones anteriores con la API._

_En cambio, el cliente abre inicialmente una conexión de larga duración con el
servidor enviando una consulta de suscripción que especifica en qué evento está
interesado. Cada vez que se produce este evento en particular, el servidor
utiliza la conexión para enviar los datos del evento al cliente o clientes
suscritos."_

> Literalmente traducido desde: https://www.howtographql.com/graphql-js/7-subscriptions/


## Aplicación a desarrollar

La idea es crear una app dónde podamos agregar reseñas o "reviews" a usuarios de
github de manera anónima. La aplicación no necesita registrar usuarios y el
único requisito es que podamos ver las reseñas en tiempo real.

<Figure image={gif}>Ejemplo de aplicación</Figure>

> El código de la aplicación está en [github]

### GraphQL

Para ésta aplicación tendremos el siguiente schema de GraphQL:

```graphql
# schema.graphql

type Query {
  getReviewsByUsername(username: String!): [Review!]!
}

type Mutation {
  createReview(reviewInput: CreateReviewInput!): Review
}

type Subscription {
  feed: NewReviewEvent!
}

input CreateReviewInput {
  username: String!
  avatarURL: String!
  content: String!
}

type Review {
  id: ID!
  username: String!
  avatarURL: String!
  content: String!
  createdAt: Int!
}

type NewReviewEvent {
  total: Int!
  newReview: GhReview!
}
```

### Estructura de directorios

```
.
├── Makefile
├── cmd
│   └── server
│       └── server.go
├── database
│   └── store.go
├── docker-compose.yml
├── go.mod
├── go.sum
├── gqlgen.yml
├── pkg
│   ├── graph
│   │   ├── exec.go
│   │   ├── model.go
│   │   ├── resolver.go
│   │   ├── schema.graphql
│   │   └── server.go
│   └── service
│       └── review.go
└── ghreviews.go

```

> [Acá](https://github.com/golang-standards/project-layout) se explica el
> estándar ocupado para ésta estructura de directorios

##### Generación de código con gqlgen

A partir de este schema graphql:

```graphql
type Subscription {
  feed: GhReviewsEvent!
}
```

[gqlgen] va a generar esta interfaz:

```go
type SubscriptionResolver interface {
	Feed(ctx context.Context) (<-chan *GhReviewsEvent, error)
}
```

> El comando para generar el código lo puedes ver el archivo [Makefile]

La parte importante es el _channel_ de retorno, lo debemos
guardar si queremos enviar datos al cliente. El parámetro `ctx` nos permitirá
saber cuándo el cliente se ha desconectado por medio de la función `ctx.Done()`.

Si queremos enviar un mensaje _broadcast_ a todos los clientes contectados,
necesitamos tener en algún lado todos los channels (conexiones) que son retornados por ésta función.
Esto se puede lograr de formar rápida con un mapa y guardar todos éstos
canales, dónde la llave sea un `chan *GhReviewsEvent`, de esta manera si
queremos borrar un canal del mapa cuando un usuario se desconecta, solamente
tenemos que llamar a `delete(mapa, llave)`.

```go
// resolver.go
package graph

import (
	"context"
	"sync"

	"github.com/mtavano/ghreviews"
)

type Resolver struct {
	reviewService ghreviews.ReviewService
	publicHubMU sync.RWMutex // debemos proteger lecturas y escrituras concurrentes en mapas en go
	publicHub   map[chan *GhReviewsEvent]bool
}

func NewResolver(logger *logrus.Logger, reviewService ghreviews.ReviewService) *Resolver {
	return &Resolver{
		reviewService: reviewService,
		publicHub:     make(map[chan *GhReviewsEvent]bool),
	}
}
```

Idealmente podríamos ocupar un `Set` en vez de un mapa, pero golang no tiene
`Set` aún (generics ftw), por comodidad ocuparemos un `map` de `chan` y `bool`,
pero no utilizaremos el valor, sólo nos interesan sus llaves.

Ya con esto resuelto, podemos implementar nuestra función `Feed` para
satisfacer la interfaz `SubscriptionResolver` generada por gqlgen:

La función `Feed` se va a ejecutar la primera vez que el cliente se conecte
(inicio de la suscripción) y su **principal objetivo** es retornar el `chan` por
el cual gqlgen enviará data al cliente. Esto quiere decir que, si queremos
enviar datos desde otras funciones/_handlers_, debemos preocuparnos de
guardar este canal y de borrarlo cuando el cliente se desconecte.

```go
// resolver.go
package graph

func (r *subscriptionResolver) Feed(ctx context.Context) (<-chan *GhReviewsEvent, error) {
	// Obtener 20 reviews más recientes
	rr, err := r.reviewService.GetLastReviews()
	if err != nil {
		return nil, err
	}

	// Obtener total de reviews
	total, err := r.reviewService.CountReviews()
	if err != nil {
		return nil, err
	}

	// Crear channel que manejará gqlgen para enviarle información al cliente
	cr := make(chan *GhReviewsEvent, 1)

	// Guardar channel en nuestro resolver para poder enviar mensajes en el futuro
	// Proteger escritura del map
	r.publicHubMU.Lock()
	r.publicHub[cr] = true
	r.publicHubMU.Unlock()

	go func() {
		// ctx.Done() retorna cuando el canal se cierra, ergo, el cliente se desconecta
		<-ctx.Done()

		// Proteger escritura del map
		r.publicHubMU.Lock()
		// Borrar channel de nuestro resolver, ya no es necesario guardarlo dado que el cliente se desconectó
		delete(r.publicHub, cr)
		r.publicHubMU.Unlock()
	}()

	// Enviar un evento al cliente
	// Este es un mensaje inicial, en dónde enviamos el total de reviews y los 20 reviews más recientes
	cr <- &GhReviewsEvent{Total: total, NewReviews: rr}

	return cr, nil
}


func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
```

Ahora podemos ocupar el mapa de conexiones dentro de la mutación
`CreateReview` y enviarle un mensaje a todos los clientes conectados

**Antes**

```go
// resolver.go
package graph

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

func (r *mutationResolver) CreateReview(ctx context.Context, reviewInput ghreviews.CreateReviewInput) (*ghreviews.GhReview, error) {
	review, err := r.reviewService.CreateReview(
		reviewInput.GithubUsername,
		reviewInput.GithubAvatarURL,
		reviewInput.Content,
	)
	if err != nil {
		return nil, err
	}

	return review, nil
}
```

Ahora, una vez que ya creamos el review, obtendremos el nuevo total y luego
enviaremos un mensaje a todos los channels/llaves del mapa `publicHub`:

```go
// resolver.go
package graph

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

func (r *mutationResolver) CreateReview(ctx context.Context, reviewInput ghreviews.CreateReviewInput) (*ghreviews.GhReview, error) {
	review, err := r.reviewService.CreateReview(
		reviewInput.GithubUsername,
		reviewInput.GithubAvatarURL,
		reviewInput.Content,
	)
	if err != nil {
		return nil, err
	}

	// --- Nuevo código
	// Obtener nuevo total
	total, err := r.reviewService.CountReviews(reviewInput.GithubUsername)
	if err != nil {
		return nil, err
	}

	// Enviamos los mensajes en una goroutine para no bloquear la ejecución de la función actual
	go func() {
		msg := &GhReviewsEvent{Total: total, NewReviews: []*ghreviews.GhReview{review}}
		// Proteger lectura del mapa
		r.publicHubMU.RLock()
		defer r.publicHubMU.RUnlock()

		// Enviamos `msg` a cada channel guardado en `publicHub`
		for channel := range r.publicHub {
			channel <- msg
		}
	}()

	return review, nil
}
```

---

La idea principal del post fue utilizar subscripciones de graphql con [apollo] y
[gqlgen], espero que te sea de ayuda y si es necesario podriamos escribir una
parte dos o entrar más en detalle ya sea en el frontend o el backend.

---

El código de [codesandbox] y [github] trae unos extras tales como
suscripciones por usuario, uso de migraciones, algunos tests y logging.

[gqlgen]: https://github.com/99designs/gqlgen
[apollo]: https://www.apollographql.com/
[mtavano]: https://github.com/mtavano
[suscripciones graphql]: https://www.apollographql.com/docs/react/data/subscriptions/
[suscripciones]: https://www.howtographql.com/graphql-js/7-subscriptions
[graphql]: https://graphql.org/
[hook]: https://es.reactjs.org/docs/hooks-intro.html
[codesandbox]: https://codesandbox.io/s/ghreviews-hu1j9
[github]: https://github.com/mtavano/ghreviews
[makefile]: https://github.com/mtavano/ghreviews/blob/master/Makefile#L12
