---
title: Suscripciones GraphQL con gqlgen
date: "2020-12-25T23:28:00.000Z"
description: "Â¿No sabes cÃ³mo implementar suscripciones de GraphQL en Golang? Este post explica cÃ³mo utilizar 
react, apollo y gqlgen"
tags: "ppoker, apipath, react, graphql, real-time, golang, subscriptions,
apollo, qlgen, gqlgen subscriptions"
---

import Figure from "../../../src/components/figure"
import landing from "./landing.png"
import reviews from "./reviews.png"

A la fecha, no hay tutoriales sobre cÃ³mo manejar suscripciones de graphql con
[gqlgen] y [apollo], por lo que quiero compartir cÃ³mo yo he utilizado ambas
tecnologÃ­as para desarrollar una simple aplicaciÃ³n.

> Debo mencionar y dar las gracias a [mtavano] por la construcciÃ³n del backend
> y la revisiÃ³n de este post ðŸ‘ðŸ‘ ðŸ‘.

En este post se asume que tienes un conocimiento bÃ¡sico de GraphQL y/o sabes
cÃ³mo escribir escribir _"queries"_ y _"mutations"_.

> Agregar links

## AplicaciÃ³n a desarrollar

La idea es crear una app dÃ³nde podamos agregar reseÃ±as o "reviews" a usuarios de
github de manera anÃ³nima. La aplicaciÃ³n no necesita registrar usuarios y el
Ãºnico requisito es que podamos ver las reseÃ±as en tiempo real.

<video controls width="100%" src="./ghreviews.webm" type="video/webm">
  Disculpa, tu navegador no es compatible con videos incrustados.
</video>

### Frontend

Comenzaremos primero descomponiendo el frontend, de esta manera tendremos una
visiÃ³n mas clara de lo que necesitamos una vez que pasemos al Backend.

La aplicaciÃ³n estÃ¡ compuesta de dos pÃ¡ginas:

#### Landing Page

En esta pÃ¡gina tenemos un input para revisar las reseÃ±as de un usuario en
especÃ­fico y tambiÃ©n tenemos la secciÃ³n de reseÃ±as en vivo, cual estarÃ¡
potenciado por [suscripciones GraphQL].

<Figure image={landing}>Landing page</Figure>

#### Review Page

Esta pÃ¡gina muestra informaciÃ³n sobre un usuario de github en especÃ­fico, por
ej, avatar, nÃºmero de seguidores y de usuarios a los que sigue, Ã©sta informaciÃ³n
la obtendremos con el API de github:

- https://api.github.com/users/:username

El valor para el campo **"REVIEWS"** serÃ¡
enviado por nuestro Backend, pero ya hablaremos de esto mÃ¡s adelante. TambiÃ©n
hay una secciÃ³n para dejar una reseÃ±a y finalmente, al igual que en la pÃ¡gina
anterior, una secciÃ³n de reseÃ±as en vivo, pero esta vez son sÃ³lo reseÃ±as que
pertenecen a este usuario.

<Figure image={reviews}>Review page</Figure>

#### Demo APP

<iframe
  src="https://codesandbox.io/embed/ghreviews-hu1j9?autoresize=1&fontsize=12&hidenavigation=1&theme=dark"
  style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
  title="ghreviews"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

El cÃ³digo de la aplicaciÃ³n estÃ¡ en:

- **Frontend**: [codesandbox]
- **Backend**: [github]

### GraphQL

Para Ã©sta aplicaciÃ³n tendremos el siguiente schema de GraphQL:

```graphql
# schema.graphql

type Query {
  # No se utiliza pero GraphQL necesita tener al menos 1 query
  getReview(id: ID!): GhReview
}

type Mutation {
  createReview(reviewInput: CreateReviewInput!): GhReview
}

type Subscription {
  feed: GhReviewsEvent!
}

input CreateReviewInput {
  githubUsername: String!
  githubAvatarURL: String!
  content: String!
}

type GhReview {
  id: ID!
  githubUsername: String!
  githubAvatarURL: String!
  content: String!
  createdAt: Int!
}

type GhReviewsEvent {
  total: Int!
  newReviews: [GhReview!]!
}
```

### Â¿QuÃ© son las suscripciones graphql?

_"Las [suscripciones] son una caracterÃ­stica de [GraphQL] que permite a un
servidor enviar datos a sus clientes cuando ocurre un evento especÃ­fico. Las
suscripciones se implementan normalmente con WebSockets. En esa configuraciÃ³n,
el servidor mantiene una conexiÃ³n constante con su cliente suscrito. Esto
tambiÃ©n rompe el "Ciclo de solicitud-respuesta"(Request-Response-Cycle) que se
utilizaba para todas las interacciones anteriores con la API._

_En cambio, el cliente abre inicialmente una conexiÃ³n de larga duraciÃ³n con el
servidor enviando una consulta de suscripciÃ³n que especifica en quÃ© evento estÃ¡
interesado. Cada vez que se produce este evento en particular, el servidor
utiliza la conexiÃ³n para enviar los datos del evento al cliente o clientes
suscritos."_

> Literalmente traducido desde: https://www.howtographql.com/graphql-js/7-subscriptions/

### Implementando suscripciones con [Apollo]

En nuestro caso tendremos la suscripciÃ³n **feed**:

```graphql
# schema.graphql

type Subscription {
  feed: GhReviewsEvent!
}

type GhReviewsEvent {
  total: Int!
  newReviews: [GhReview!]!
}

type GhReview {
  id: ID!
  githubUsername: String!
  githubAvatarURL: String!
  content: String!
  createdAt: Int!
}
```

Ã‰sta suscripciÃ³n recibirÃ¡ un mensaje del tipo `GhReviewsEvent`, en dÃ³nde
recibiremos:

- `total`: representa la cantidad total de _"reviews"_
- `newReviews`: un arreglo con las nuevas reseÃ±as, por lo general serÃ¡ un
  arreglo de largo 1, a diferencia de la primera vez que el cliente se suscriba,
  en ese caso enviaremos los 20 reviews mas recientes

**SuscripciÃ³n feed**

Partiremos definiendo cÃ³mo esperamos consumir la data desde nuestros componentes:

```jsx
function LandingPage() {
  const {
    data: { reviews, total },
    loading,
    error,
  } = useFeed();

  return (
    ...
  );
}
```

Queremos tener un [hook] llamado `useFeed` que nos retorne un objeto `data` que
contenga siempre un arreglo de `reviews` y un `total`. En un inicio, la variable
`reviews` serÃ¡ un arreglo vacÃ­o y `total` serÃ¡ `0`, ya una vez el servidor
emita un `GhReviewsEvent`, actualizaremos sus respectivos valores:

```js
// use-feed.js

import { useState, useEffect } from "react"
import { gql, useSubscription } from "@apollo/client"

const MAX_REVIEWS = 20

const FEED_PUBLIC_SUBSCRIPTION = gql`
  subscription PublicFeed {
    feed {
      total
      newReviews {
        id
        content
        githubUsername
        githubAvatarURL
        createdAt
      }
    }
  }
`

function useFeed() {
  const { data, loading, error } = useSubscription(FEED_PUBLIC_SUBSCRIPTION)

  const total = data?.feed.total ?? 0
  const reviews = data?.feed.newReviews ?? []

  return { data: { reviews, total }, loading, error }
}

export default useFeed
```

Esta implementaciÃ³n tiene un solo problema, dado que el servidor siempre retorna
nuevos reviews, significa que cada vez que recibamos un `GhReviewsEvent`, perderemos los
reviews anteriores. Para solucionar este problema utilizaremos `useState` y
guardaremos todos los reviews recibidos:

```js
import { useState, useEffect } from "react"
import { gql, useSubscription } from "@apollo/client"

const MAX_REVIEWS = 20

const FEED_PUBLIC_SUBSCRIPTION = gql`
  subscription PublicFeed {
    feed {
      total
      newReviews {
        id
        content
        githubUsername
        githubAvatarURL
        createdAt
      }
    }
  }
`

function useFeed() {
  const { data, loading, error } = useSubscription(FEED_PUBLIC_SUBSCRIPTION)
  const [reviews, setReviews] = useState([])
  useEffect(() => {
    if (!data || data.feed.newReviews.length === 0) return

    setReviews(reviews =>
      [...data.feed.newReviews, ...reviews].slice(0, MAX_REVIEWS)
    )
  }, [data])

  const total = data?.feed?.total ?? 0
  return { data: { reviews, total }, loading, error }
}

export default useFeed
```

### Backend

#### Estructura de directorios

```
.
â”œâ”€â”€ Makefile
â”œâ”€â”€ cmd
â”‚Â Â  â””â”€â”€ server
â”‚Â Â      â””â”€â”€ server.go
â”œâ”€â”€ database
â”‚Â Â  â”œâ”€â”€ count_reviews.go
â”‚Â Â  â”œâ”€â”€ create_review.go
â”‚Â Â  â”œâ”€â”€ create_review_test.go
â”‚Â Â  â”œâ”€â”€ get_last_reviews.go
â”‚Â Â  â”œâ”€â”€ review.go
â”‚Â Â  â””â”€â”€ store.go
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ gqlgen.yml
â”œâ”€â”€ pkg
â”‚Â Â  â”œâ”€â”€ graph
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ exec.go
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ model.go
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ resolver.go
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ schema.graphql
â”‚Â Â  â”‚Â Â  â””â”€â”€ server.go
â”‚Â Â  â””â”€â”€ service
â”‚Â Â      â””â”€â”€ review.go
â”œâ”€â”€ ghreviews.go
â””â”€â”€ testutil
    â””â”€â”€ get_test_db.go

```

En este caso, todo lo relativo a la aplicaciÃ³n quedarÃ¡ en `pkg` mientras que la definiciones
de tipos y dominio de datos quedaran a nivel de root y `database` respectivamente

##### GeneraciÃ³n de cÃ³digo con gqlgen

A partir de este schema graphql:

```graphql
type Subscription {
  feed: GhReviewsEvent!
}
```

[gqlgen] va a generar esta interfaz:

```go
type SubscriptionResolver interface {
	Feed(ctx context.Context) (<-chan *GhReviewsEvent, error)
}
```

> El comando para generar el cÃ³digo lo puedes ver el archivo [Makefile]

La parte importante es el _channel_ de retorno, lo debemos
guardar si queremos enviar datos al cliente. El parÃ¡metro `ctx` nos permitirÃ¡
saber cuÃ¡ndo el cliente se ha desconectado por medio de la funciÃ³n `ctx.Done()`.

Si queremos enviar un mensaje _broadcast_ a todos los clientes contectados,
necesitamos tener en algÃºn lado todos los channels (conexiones) que son retornados por Ã©sta funciÃ³n.
Esto se puede lograr de formar rÃ¡pida con un mapa y guardar todos Ã©stos
canales, dÃ³nde la llave sea un `chan *GhReviewsEvent`, de esta manera si
queremos borrar un canal del mapa cuando un usuario se desconecta, solamente
tenemos que llamar a `delete(mapa, llave)`.

```go
// resolver.go
package graph

import (
	"context"
	"sync"

	"github.com/mtavano/ghreviews"
)

type Resolver struct {
	reviewService ghreviews.ReviewService
	publicHubMU sync.RWMutex // debemos proteger lecturas y escrituras concurrentes en mapas en go
	publicHub   map[chan *GhReviewsEvent]bool
}

func NewResolver(logger *logrus.Logger, reviewService ghreviews.ReviewService) *Resolver {
	return &Resolver{
		reviewService: reviewService,
		publicHub:     make(map[chan *GhReviewsEvent]bool),
	}
}
```

Idealmente podrÃ­amos ocupar un `Set` en vez de un mapa, pero golang no tiene
`Set` aÃºn (generics ftw), por comodidad ocuparemos un `map` de `chan` y `bool`,
pero no utilizaremos el valor, sÃ³lo nos interesan sus llaves.

Ya con esto resuelto, podemos implementar nuestra funciÃ³n `Feed` para
satisfacer la interfaz `SubscriptionResolver` generada por gqlgen:

La funciÃ³n `Feed` se va a ejecutar la primera vez que el cliente se conecte
(inicio de la suscripciÃ³n) y su **principal objetivo** es retornar el `chan` por
el cual gqlgen enviarÃ¡ data al cliente. Esto quiere decir que, si queremos
enviar datos desde otras funciones/_handlers_, debemos preocuparnos de
guardar este canal y de borrarlo cuando el cliente se desconecte.

```go
// resolver.go
package graph
import (...)

func (r *subscriptionResolver) Feed(ctx context.Context) (<-chan *GhReviewsEvent, error) {
	// Obtener 20 reviews mÃ¡s recientes
	rr, err := r.reviewService.GetLastReviews()
	if err != nil {
		return nil, err
	}

	// Obtener total de reviews
	total, err := r.reviewService.CountReviews()
	if err != nil {
		return nil, err
	}

	// Crear channel que manejarÃ¡ gqlgen para enviarle informaciÃ³n al cliente
	cr := make(chan *GhReviewsEvent, 1)

	// Guardar channel en nuestro resolver para poder enviar mensajes en el futuro
	// Proteger escritura del map
	r.publicHubMU.Lock()
	r.publicHub[cr] = true
	r.publicHubMU.Unlock()

	go func() {
		// ctx.Done() retorna cuando el canal se cierra, ergo, el cliente se desconecta
		<-ctx.Done()

		// Proteger escritura del map
		r.publicHubMU.Lock()
		// Borrar channel de nuestro resolver, ya no es necesario guardarlo dado que el cliente se desconectÃ³
		delete(r.publicHub, cr)
		r.publicHubMU.Unlock()
	}()

	// Enviar un evento al cliente
	// Este es un mensaje inicial, en dÃ³nde enviamos el total de reviews y los 20 reviews mÃ¡s recientes
	cr <- &GhReviewsEvent{Total: total, NewReviews: rr}

	return cr, nil
}


func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
```

Ahora podemos ocupar el mapa de conexiones dentro de la mutaciÃ³n
`CreateReview` y enviarle un mensaje a todos los clientes conectados

**Antes**

```go
// resolver.go
package graph

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

func (r *mutationResolver) CreateReview(ctx context.Context, reviewInput ghreviews.CreateReviewInput) (*ghreviews.GhReview, error) {
	review, err := r.reviewService.CreateReview(
		reviewInput.GithubUsername,
		reviewInput.GithubAvatarURL,
		reviewInput.Content,
	)
	if err != nil {
		return nil, err
	}

	return review, nil
}
```

Ahora, una vez que ya creamos el review, obtendremos el nuevo total y luego
enviaremos un mensaje a todos los channels/llaves del mapa `publicHub`:

```go
// resolver.go
package graph

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

func (r *mutationResolver) CreateReview(ctx context.Context, reviewInput ghreviews.CreateReviewInput) (*ghreviews.GhReview, error) {
	review, err := r.reviewService.CreateReview(
		reviewInput.GithubUsername,
		reviewInput.GithubAvatarURL,
		reviewInput.Content,
	)
	if err != nil {
		return nil, err
	}

	// --- Nuevo cÃ³digo
	// Obtener nuevo total
	total, err := r.reviewService.CountReviews(reviewInput.GithubUsername)
	if err != nil {
		return nil, err
	}

	// Enviamos los mensajes en una goroutine para no bloquear la ejecuciÃ³n de la funciÃ³n actual
	go func() {
		msg := &GhReviewsEvent{Total: total, NewReviews: []*ghreviews.GhReview{review}}
		// Proteger lectura del mapa
		r.publicHubMU.RLock()
		defer r.publicHubMU.RUnlock()

		// Enviamos `msg` a cada channel guardado en `publicHub`
		for channel := range r.publicHub {
			channel <- msg
		}
	}()

	return review, nil
}
```

---

La idea principal del post fue utilizar subscripciones de graphql con [apollo] y
[gqlgen], espero que te sea de ayuda y si es necesario podriamos escribir una
parte dos o entrar mÃ¡s en detalle ya sea en el frontend o el backend.

---

El cÃ³digo de [codesandbox] y [github] trae unos extras tales como
suscripciones por usuario, uso de migraciones, algunos tests y logging.

[gqlgen]: https://github.com/99designs/gqlgen
[apollo]: https://www.apollographql.com/
[mtavano]: https://github.com/mtavano
[suscripciones graphql]: https://www.apollographql.com/docs/react/data/subscriptions/
[suscripciones]: https://www.howtographql.com/graphql-js/7-subscriptions
[graphql]: https://graphql.org/
[hook]: https://es.reactjs.org/docs/hooks-intro.html
[codesandbox]: https://codesandbox.io/s/ghreviews-hu1j9
[github]: https://github.com/mtavano/ghreviews
[makefile]: https://github.com/mtavano/ghreviews/blob/master/Makefile#L12
